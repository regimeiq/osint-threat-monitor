"""Situation Report (SITREP) generator for protective intelligence.

SITREPs are event-triggered intelligence products generated when:
- A POI's TAS score crosses an escalation threshold
- An alert occurs within a protected location's radius
- A travel disruption affects a planned movement
- An analyst manually triggers one for an active situation
"""

import json

import yaml

from analytics.governance import redact_text
from analytics.utils import utcnow
from database.init_db import get_connection, WATCHLIST_CONFIG_PATH


def _load_escalation_tiers():
    """Load escalation tier config from watchlist.yaml."""
    try:
        with open(WATCHLIST_CONFIG_PATH, "r") as fh:
            config = yaml.safe_load(fh) or {}
        return config.get("escalation_tiers", [])
    except Exception:
        return [
            {"threshold": 85, "label": "CRITICAL", "notify": ["detail_leader", "intel_manager"],
             "action": "Immediate briefing required.", "response_window": "30 minutes"},
            {"threshold": 65, "label": "ELEVATED", "notify": ["intel_analyst"],
             "action": "Enhanced monitoring. Assess within 4 hours.", "response_window": "4 hours"},
            {"threshold": 40, "label": "ROUTINE", "notify": [],
             "action": "Log and monitor.", "response_window": "24 hours"},
            {"threshold": 0, "label": "LOW", "notify": [],
             "action": "No immediate action.", "response_window": "N/A"},
        ]


def _resolve_escalation_tier(score):
    """Determine escalation tier for a given score."""
    tiers = _load_escalation_tiers()
    if not tiers:
        return {"label": "ROUTINE", "notify": [], "action": "Monitor.", "response_window": "24 hours"}
    tiers_sorted = sorted(tiers, key=lambda t: t.get("threshold", 0), reverse=True)
    for tier in tiers_sorted:
        if score >= tier.get("threshold", 0):
            return tier
    return tiers_sorted[-1] if tiers_sorted else {"label": "LOW", "notify": [], "action": "Archive."}


def _build_sitrep_markdown(sitrep_data):
    """Render a SITREP as markdown."""
    lines = []
    lines.append(f"# SITREP: {sitrep_data['title']}")
    lines.append("")
    lines.append(f"**Severity:** {sitrep_data['severity']}  ")
    lines.append(f"**Trigger:** {sitrep_data['trigger_type']}  ")
    lines.append(f"**Generated:** {sitrep_data.get('created_at', 'N/A')}  ")
    lines.append(f"**Escalation Tier:** {sitrep_data.get('escalation_tier', 'N/A')}  ")
    lines.append(f"**Response Window:** {sitrep_data.get('response_window', 'N/A')}  ")
    lines.append("")

    lines.append("## Situation Summary")
    lines.append(sitrep_data.get("situation_summary", "No details available."))
    lines.append("")

    if sitrep_data.get("threat_assessment"):
        lines.append("## Threat Assessment")
        lines.append(sitrep_data["threat_assessment"])
        lines.append("")

    affected_protectees = sitrep_data.get("affected_protectees", [])
    if affected_protectees:
        lines.append("## Affected Protectees")
        for p in affected_protectees:
            lines.append(f"- {p}")
        lines.append("")

    affected_locations = sitrep_data.get("affected_locations", [])
    if affected_locations:
        lines.append("## Affected Locations")
        for loc in affected_locations:
            lines.append(f"- {loc}")
        lines.append("")

    actions = sitrep_data.get("recommended_actions", [])
    if actions:
        lines.append("## Recommended Actions")
        for i, action in enumerate(actions, 1):
            lines.append(f"{i}. {action}")
        lines.append("")

    notify = sitrep_data.get("escalation_notify", [])
    if notify:
        lines.append("## Notification")
        lines.append(f"Notify: {', '.join(notify)}")
        lines.append("")

    lines.append("---")
    lines.append("*This SITREP was auto-generated by the Protective Intelligence Assistant.*")
    return "\n".join(lines)


def generate_sitrep_for_poi_escalation(conn, poi_id, assessment):
    """Generate a SITREP when a POI's TAS crosses an escalation threshold."""
    poi_row = conn.execute("SELECT * FROM pois WHERE id = ?", (poi_id,)).fetchone()
    if not poi_row:
        return None
    poi = dict(poi_row)

    tas_score = float(assessment.get("tas_score", 0))
    tier = _resolve_escalation_tier(tas_score)

    flags_fired = []
    for flag in ["fixation", "energy_burst", "leakage", "pathway", "targeting_specificity"]:
        if int(assessment.get(flag, 0)) == 1:
            flags_fired.append(flag.replace("_", " ").title())

    evidence = assessment.get("evidence", {})
    excerpts = evidence.get("excerpts", [])

    situation_summary = (
        f"Threat Assessment Score for {poi['name']} ({poi.get('role', 'N/A')}, "
        f"{poi.get('org', 'N/A')}) has reached {tas_score:.1f}/100. "
        f"TRAP-lite flags triggered: {', '.join(flags_fired) if flags_fired else 'None'}. "
        f"Assessment window: {assessment.get('window_start', 'N/A')} to {assessment.get('window_end', 'N/A')}."
    )

    threat_assessment = (
        f"The protectee has been referenced in {evidence.get('hits', 0)} alert(s) "
        f"across {evidence.get('distinct_days', 0)} distinct day(s). "
    )
    if "increasing" == assessment.get("escalation_trend", "stable"):
        threat_assessment += "The trend is INCREASING — activity is escalating. "
    if flags_fired:
        threat_assessment += f"Active behavioral indicators: {', '.join(flags_fired)}. "
    if excerpts:
        threat_assessment += f"Key evidence: \"{excerpts[0][:200]}\""

    actions = [tier.get("action", "Monitor.")]
    if tas_score >= 65:
        actions.append("Review all POI hits for the assessment window.")
        actions.append("Verify protectee's current location and upcoming movements.")
    if tas_score >= 85:
        actions.insert(0, "IMMEDIATE: Brief detail leader and intel manager.")
        actions.append("Consider enhanced protective posture.")

    sitrep_data = {
        "trigger_type": "poi_escalation",
        "trigger_poi_id": poi_id,
        "severity": "CRITICAL" if tas_score >= 85 else "ELEVATED" if tas_score >= 65 else "ROUTINE",
        "title": f"POI Escalation: {poi['name']} — TAS {tas_score:.1f}",
        "situation_summary": situation_summary,
        "threat_assessment": threat_assessment,
        "affected_protectees": [poi["name"]],
        "affected_locations": [],
        "recommended_actions": actions,
        "escalation_tier": tier.get("label", "ROUTINE"),
        "escalation_notify": tier.get("notify", []),
        "response_window": tier.get("response_window", "N/A"),
        "created_at": utcnow().strftime("%Y-%m-%d %H:%M:%S"),
    }

    content_md = _build_sitrep_markdown(sitrep_data)
    content_md = redact_text(conn, content_md)

    conn.execute(
        """INSERT INTO sitreps
        (trigger_type, trigger_poi_id, severity, title, situation_summary,
         threat_assessment, affected_protectees, affected_locations,
         recommended_actions, escalation_tier, escalation_notify, content_md, status)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'draft')""",
        (
            "poi_escalation",
            poi_id,
            sitrep_data["severity"],
            sitrep_data["title"],
            situation_summary,
            threat_assessment,
            json.dumps(sitrep_data["affected_protectees"]),
            json.dumps(sitrep_data["affected_locations"]),
            json.dumps(actions),
            tier.get("label"),
            json.dumps(tier.get("notify", [])),
            content_md,
        ),
    )
    sitrep_id = conn.execute("SELECT last_insert_rowid()").fetchone()[0]
    sitrep_data["id"] = sitrep_id
    sitrep_data["content_md"] = content_md
    return sitrep_data


def generate_sitrep_for_facility_breach(conn, alert_id, location_id):
    """Generate a SITREP when an alert occurs within a protected location's radius."""
    alert = conn.execute("SELECT * FROM alerts WHERE id = ?", (alert_id,)).fetchone()
    location = conn.execute(
        "SELECT * FROM protected_locations WHERE id = ?", (location_id,)
    ).fetchone()
    if not alert or not location:
        return None

    proximity = conn.execute(
        """SELECT distance_miles, within_radius FROM alert_proximity
        WHERE alert_id = ? AND protected_location_id = ?""",
        (alert_id, location_id),
    ).fetchone()

    ors = float(alert.get("ors_score") or alert.get("risk_score") or 0)
    tier = _resolve_escalation_tier(ors)
    distance = float(proximity["distance_miles"]) if proximity else None

    situation_summary = (
        f"Alert #{alert_id} ({alert['title'][:100]}) detected "
        f"{'within' if proximity and int(proximity['within_radius']) else 'near'} "
        f"protected location '{location['name']}'"
        f"{f' ({distance:.1f} miles)' if distance is not None else ''}. "
        f"ORS: {ors:.1f}."
    )

    actions = [tier.get("action", "Monitor.")]
    if ors >= 70:
        actions.append("Verify physical security posture at the facility.")
        actions.append("Cross-reference with recent POI activity in the area.")

    sitrep_data = {
        "trigger_type": "facility_breach",
        "trigger_alert_id": alert_id,
        "trigger_location_id": location_id,
        "severity": "CRITICAL" if ors >= 85 else "ELEVATED" if ors >= 65 else "ROUTINE",
        "title": f"Facility Alert: {location['name']} — ORS {ors:.1f}",
        "situation_summary": situation_summary,
        "threat_assessment": f"A threat-related alert is proximate to a protected facility. Severity: {alert.get('severity', 'unknown')}.",
        "affected_protectees": [],
        "affected_locations": [location["name"]],
        "recommended_actions": actions,
        "escalation_tier": tier.get("label", "ROUTINE"),
        "escalation_notify": tier.get("notify", []),
        "response_window": tier.get("response_window", "N/A"),
        "created_at": utcnow().strftime("%Y-%m-%d %H:%M:%S"),
    }

    content_md = _build_sitrep_markdown(sitrep_data)
    content_md = redact_text(conn, content_md)

    conn.execute(
        """INSERT INTO sitreps
        (trigger_type, trigger_alert_id, trigger_location_id, severity, title,
         situation_summary, threat_assessment, affected_protectees, affected_locations,
         recommended_actions, escalation_tier, escalation_notify, content_md, status)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'draft')""",
        (
            "facility_breach",
            alert_id,
            location_id,
            sitrep_data["severity"],
            sitrep_data["title"],
            situation_summary,
            sitrep_data["threat_assessment"],
            json.dumps(sitrep_data["affected_protectees"]),
            json.dumps(sitrep_data["affected_locations"]),
            json.dumps(actions),
            tier.get("label"),
            json.dumps(tier.get("notify", [])),
            content_md,
        ),
    )
    sitrep_id = conn.execute("SELECT last_insert_rowid()").fetchone()[0]
    sitrep_data["id"] = sitrep_id
    sitrep_data["content_md"] = content_md
    return sitrep_data


def list_sitreps(conn, status=None, limit=20):
    """List recent SITREPs."""
    query = "SELECT * FROM sitreps"
    params = []
    if status:
        query += " WHERE status = ?"
        params.append(status)
    query += " ORDER BY created_at DESC LIMIT ?"
    params.append(limit)
    return [dict(row) for row in conn.execute(query, params).fetchall()]


def issue_sitrep(conn, sitrep_id):
    """Mark a SITREP as issued (sent up the chain)."""
    conn.execute(
        "UPDATE sitreps SET status = 'issued', issued_at = ? WHERE id = ?",
        (utcnow().strftime("%Y-%m-%d %H:%M:%S"), sitrep_id),
    )
    return conn.execute("SELECT * FROM sitreps WHERE id = ?", (sitrep_id,)).fetchone()
